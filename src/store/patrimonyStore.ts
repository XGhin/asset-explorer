import { create } from 'zustand';
import { FolderNode, Expense, TreeNode, ITEM_SUBFOLDERS, PathSegment } from '@/types/patrimony';

interface PatrimonyState {
  folders: FolderNode[];
  expenses: Expense[];
  selectedFolderId: string | null;
  expandedIds: string[];
  
  // Actions
  addFolder: (name: string, parentId: string | null, type: 'folder' | 'item') => void;
  addExpense: (expense: Omit<Expense, 'id' | 'createdAt'>) => void;
  selectFolder: (id: string | null) => void;
  toggleExpand: (id: string) => void;
  expandAll: () => void;
  collapseAll: () => void;
}

const generateId = () => Math.random().toString(36).substring(2, 15);

// Initial demo data
const initialFolders: FolderNode[] = [
  { id: 'empresa-01', name: 'EMPRESA-01', type: 'folder', parentId: null, createdAt: new Date() },
  { id: 'empresa-02', name: 'EMPRESA-02', type: 'folder', parentId: null, createdAt: new Date() },
  { id: 'primeiro-andar', name: 'Primeiro Andar', type: 'folder', parentId: 'empresa-02', createdAt: new Date() },
  { id: 'setor-financeiro', name: 'Setor Financeiro', type: 'folder', parentId: 'primeiro-andar', createdAt: new Date() },
  { id: 'calc-01', name: 'CALCULADORA-01', type: 'item', parentId: 'setor-financeiro', createdAt: new Date() },
  { id: 'calc-01-aquisicao', name: 'Aquisição', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'calc-01-manutencao', name: 'Manutenção', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'calc-01-documentos', name: 'Documentos', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'calc-01-upgrades', name: 'Upgrades', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'segundo-andar', name: 'Segundo Andar', type: 'folder', parentId: 'empresa-02', createdAt: new Date() },
  { id: 'setor-ti', name: 'Setor TI', type: 'folder', parentId: 'segundo-andar', createdAt: new Date() },
  { id: 'pc-01', name: 'PC-DESKTOP-01', type: 'item', parentId: 'setor-ti', createdAt: new Date() },
  { id: 'pc-01-aquisicao', name: 'Aquisição', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'pc-01-manutencao', name: 'Manutenção', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'pc-01-documentos', name: 'Documentos', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'pc-01-upgrades', name: 'Upgrades', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
];

const initialExpenses: Expense[] = [
  { id: 'exp-1', folderId: 'calc-01-aquisicao', category: 'Aquisição', value: 89.90, date: new Date('2024-01-15'), description: 'Compra da calculadora HP 12C', createdAt: new Date() },
  { id: 'exp-2', folderId: 'calc-01-manutencao', category: 'Manutenção', value: 35.00, date: new Date('2024-06-10'), description: 'Troca de pilhas e limpeza', createdAt: new Date() },
  { id: 'exp-3', folderId: 'pc-01-aquisicao', category: 'Aquisição', value: 4500.00, date: new Date('2024-02-20'), description: 'Desktop i7 16GB RAM 512GB SSD', createdAt: new Date() },
  { id: 'exp-4', folderId: 'pc-01-manutencao', category: 'Manutenção', value: 150.00, date: new Date('2024-08-05'), description: 'Limpeza interna e troca de pasta térmica', createdAt: new Date() },
  { id: 'exp-5', folderId: 'pc-01-upgrades', category: 'Upgrades', value: 320.00, date: new Date('2024-09-12'), description: 'Upgrade de RAM para 32GB', createdAt: new Date() },
];

export const usePatrimonyStore = create<PatrimonyState>()((set) => ({
  folders: initialFolders,
  expenses: initialExpenses,
  selectedFolderId: null,
  expandedIds: ['empresa-02', 'primeiro-andar', 'setor-financeiro', 'calc-01', 'segundo-andar', 'setor-ti', 'pc-01'],

  addFolder: (name, parentId, type) => {
    const id = generateId();
    const newFolder: FolderNode = {
      id,
      name,
      type,
      parentId,
      createdAt: new Date(),
    };

    set((state) => {
      let newFolders = [...state.folders, newFolder];
      let newExpandedIds = [...state.expandedIds];

      // If it's an item, create auto subfolders
      if (type === 'item') {
        const subfolders: FolderNode[] = ITEM_SUBFOLDERS.map((subName) => ({
          id: generateId(),
          name: subName,
          type: 'folder' as const,
          parentId: id,
          isAutoGenerated: true,
          createdAt: new Date(),
        }));
        newFolders = [...newFolders, ...subfolders];
        if (!newExpandedIds.includes(id)) {
          newExpandedIds.push(id);
        }
      }

      // Expand parent when adding
      if (parentId && !newExpandedIds.includes(parentId)) {
        newExpandedIds.push(parentId);
      }

      return { folders: newFolders, expandedIds: newExpandedIds };
    });
  },

  addExpense: (expenseData) => {
    const expense: Expense = {
      ...expenseData,
      id: generateId(),
      createdAt: new Date(),
    };
    set((state) => ({ expenses: [...state.expenses, expense] }));
  },

  selectFolder: (id) => set({ selectedFolderId: id }),

  toggleExpand: (id) => {
    set((state) => {
      const isExpanded = state.expandedIds.includes(id);
      return {
        expandedIds: isExpanded
          ? state.expandedIds.filter((i) => i !== id)
          : [...state.expandedIds, id],
      };
    });
  },

  expandAll: () => {
    set((state) => ({
      expandedIds: state.folders.map((f) => f.id),
    }));
  },

  collapseAll: () => set({ expandedIds: [] }),
}));

// Helper functions (not selectors, used in components)
export function getRootFolders(folders: FolderNode[]): FolderNode[] {
  return folders.filter((f) => f.parentId === null);
}

export function getSelectedFolder(folders: FolderNode[], selectedFolderId: string | null): FolderNode | null {
  return folders.find((f) => f.id === selectedFolderId) || null;
}

export function getPath(folders: FolderNode[], folderId: string): PathSegment[] {
  const path: PathSegment[] = [];
  let currentId: string | null = folderId;

  while (currentId) {
    const folder = folders.find((f) => f.id === currentId);
    if (folder) {
      path.unshift({ id: folder.id, name: folder.name });
      currentId = folder.parentId;
    } else {
      break;
    }
  }

  return path;
}

export function buildTree(folders: FolderNode[], expenses: Expense[], parentId: string | null): TreeNode[] {
  return folders
    .filter((f) => f.parentId === parentId)
    .map((folder) => ({
      ...folder,
      children: buildTree(folders, expenses, folder.id),
      expenses: expenses.filter((e) => e.folderId === folder.id),
    }))
    .sort((a, b) => {
      if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
      return a.name.localeCompare(b.name);
    });
}

export function getTotalExpenses(folders: FolderNode[], expenses: Expense[], folderId: string): number {
  const getAllDescendantIds = (id: string): string[] => {
    const children = folders.filter((f) => f.parentId === id);
    return [id, ...children.flatMap((c) => getAllDescendantIds(c.id))];
  };

  const allIds = getAllDescendantIds(folderId);
  return expenses
    .filter((e) => allIds.includes(e.folderId))
    .reduce((sum, e) => sum + e.value, 0);
}

export function getFolderExpenses(
  folders: FolderNode[],
  expenses: Expense[],
  folderId: string,
  recursive: boolean
): Array<Expense & { folderPath: string; itemName?: string }> {
  const getAllDescendantIds = (id: string): string[] => {
    const children = folders.filter((f) => f.parentId === id);
    return [id, ...children.flatMap((c) => getAllDescendantIds(c.id))];
  };

  const targetIds = recursive ? getAllDescendantIds(folderId) : [folderId];
  
  return expenses
    .filter((e) => targetIds.includes(e.folderId))
    .map((e) => {
      const path = getPath(folders, e.folderId);
      const folder = folders.find((f) => f.id === e.folderId);
      const parent = folder?.parentId ? folders.find((f) => f.id === folder.parentId) : null;
      
      return {
        ...e,
        folderPath: path.map((p) => p.name).join(' > '),
        itemName: parent?.type === 'item' ? parent.name : folder?.type === 'item' ? folder.name : undefined,
      };
    })
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}
