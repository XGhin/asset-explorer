import { create } from 'zustand';
import { FolderNode, Expense, TreeNode, ITEM_SUBFOLDERS, PathSegment } from '@/types/patrimony';

interface PatrimonyState {
  folders: FolderNode[];
  expenses: Expense[];
  selectedFolderId: string | null;
  expandedIds: Set<string>;
  
  // Actions
  addFolder: (name: string, parentId: string | null, type: 'folder' | 'item') => void;
  addExpense: (expense: Omit<Expense, 'id' | 'createdAt'>) => void;
  selectFolder: (id: string | null) => void;
  toggleExpand: (id: string) => void;
  expandAll: () => void;
  collapseAll: () => void;
  
  // Computed
  getTree: () => TreeNode[];
  getSelectedFolder: () => FolderNode | null;
  getPath: (folderId: string) => PathSegment[];
  getTotalExpenses: (folderId: string) => number;
  getFolderExpenses: (folderId: string, recursive: boolean) => Array<Expense & { folderPath: string; itemName?: string }>;
  getRootFolders: () => FolderNode[];
}

const generateId = () => Math.random().toString(36).substring(2, 15);

// Initial demo data
const initialFolders: FolderNode[] = [
  { id: 'empresa-01', name: 'EMPRESA-01', type: 'folder', parentId: null, createdAt: new Date() },
  { id: 'empresa-02', name: 'EMPRESA-02', type: 'folder', parentId: null, createdAt: new Date() },
  { id: 'primeiro-andar', name: 'Primeiro Andar', type: 'folder', parentId: 'empresa-02', createdAt: new Date() },
  { id: 'setor-financeiro', name: 'Setor Financeiro', type: 'folder', parentId: 'primeiro-andar', createdAt: new Date() },
  { id: 'calc-01', name: 'CALCULADORA-01', type: 'item', parentId: 'setor-financeiro', createdAt: new Date() },
  { id: 'calc-01-aquisicao', name: 'Aquisição', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'calc-01-manutencao', name: 'Manutenção', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'calc-01-documentos', name: 'Documentos', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'calc-01-upgrades', name: 'Upgrades', type: 'folder', parentId: 'calc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'segundo-andar', name: 'Segundo Andar', type: 'folder', parentId: 'empresa-02', createdAt: new Date() },
  { id: 'setor-ti', name: 'Setor TI', type: 'folder', parentId: 'segundo-andar', createdAt: new Date() },
  { id: 'pc-01', name: 'PC-DESKTOP-01', type: 'item', parentId: 'setor-ti', createdAt: new Date() },
  { id: 'pc-01-aquisicao', name: 'Aquisição', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'pc-01-manutencao', name: 'Manutenção', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'pc-01-documentos', name: 'Documentos', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
  { id: 'pc-01-upgrades', name: 'Upgrades', type: 'folder', parentId: 'pc-01', isAutoGenerated: true, createdAt: new Date() },
];

const initialExpenses: Expense[] = [
  { id: 'exp-1', folderId: 'calc-01-aquisicao', category: 'Aquisição', value: 89.90, date: new Date('2024-01-15'), description: 'Compra da calculadora HP 12C', createdAt: new Date() },
  { id: 'exp-2', folderId: 'calc-01-manutencao', category: 'Manutenção', value: 35.00, date: new Date('2024-06-10'), description: 'Troca de pilhas e limpeza', createdAt: new Date() },
  { id: 'exp-3', folderId: 'pc-01-aquisicao', category: 'Aquisição', value: 4500.00, date: new Date('2024-02-20'), description: 'Desktop i7 16GB RAM 512GB SSD', createdAt: new Date() },
  { id: 'exp-4', folderId: 'pc-01-manutencao', category: 'Manutenção', value: 150.00, date: new Date('2024-08-05'), description: 'Limpeza interna e troca de pasta térmica', createdAt: new Date() },
  { id: 'exp-5', folderId: 'pc-01-upgrades', category: 'Upgrades', value: 320.00, date: new Date('2024-09-12'), description: 'Upgrade de RAM para 32GB', createdAt: new Date() },
];

export const usePatrimonyStore = create<PatrimonyState>()((set, get) => ({
  folders: initialFolders,
  expenses: initialExpenses,
  selectedFolderId: null,
  expandedIds: new Set<string>(['empresa-02', 'primeiro-andar', 'setor-financeiro', 'calc-01', 'segundo-andar', 'setor-ti', 'pc-01']),

  addFolder: (name, parentId, type) => {
    const id = generateId();
    const newFolder: FolderNode = {
      id,
      name,
      type,
      parentId,
      createdAt: new Date(),
    };

    set((state) => {
      let newFolders = [...state.folders, newFolder];
      let newExpenses = [...state.expenses];
      let newExpandedIds = new Set(state.expandedIds);

      // If it's an item, create auto subfolders and initial acquisition expense
      if (type === 'item') {
        const subfolders: FolderNode[] = ITEM_SUBFOLDERS.map((subName) => ({
          id: generateId(),
          name: subName,
          type: 'folder' as const,
          parentId: id,
          isAutoGenerated: true,
          createdAt: new Date(),
        }));
        newFolders = [...newFolders, ...subfolders];
        newExpandedIds.add(id);
      }

      // Expand parent when adding
      if (parentId) {
        newExpandedIds.add(parentId);
      }

      return { folders: newFolders, expenses: newExpenses, expandedIds: newExpandedIds };
    });

    return id;
  },

  addExpense: (expenseData) => {
    const expense: Expense = {
      ...expenseData,
      id: generateId(),
      createdAt: new Date(),
    };
    set((state) => ({ expenses: [...state.expenses, expense] }));
  },

  selectFolder: (id) => set({ selectedFolderId: id }),

  toggleExpand: (id) => {
    set((state) => {
      const newExpanded = new Set(state.expandedIds);
      if (newExpanded.has(id)) {
        newExpanded.delete(id);
      } else {
        newExpanded.add(id);
      }
      return { expandedIds: newExpanded };
    });
  },

  expandAll: () => {
    set((state) => ({
      expandedIds: new Set(state.folders.map((f) => f.id)),
    }));
  },

  collapseAll: () => set({ expandedIds: new Set() }),

  getTree: () => {
    const { folders, expenses } = get();
    
    const buildTree = (parentId: string | null): TreeNode[] => {
      return folders
        .filter((f) => f.parentId === parentId)
        .map((folder) => ({
          ...folder,
          children: buildTree(folder.id),
          expenses: expenses.filter((e) => e.folderId === folder.id),
        }))
        .sort((a, b) => {
          // Items come after folders
          if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
          return a.name.localeCompare(b.name);
        });
    };

    return buildTree(null);
  },

  getSelectedFolder: () => {
    const { folders, selectedFolderId } = get();
    return folders.find((f) => f.id === selectedFolderId) || null;
  },

  getPath: (folderId) => {
    const { folders } = get();
    const path: PathSegment[] = [];
    let currentId: string | null = folderId;

    while (currentId) {
      const folder = folders.find((f) => f.id === currentId);
      if (folder) {
        path.unshift({ id: folder.id, name: folder.name });
        currentId = folder.parentId;
      } else {
        break;
      }
    }

    return path;
  },

  getTotalExpenses: (folderId) => {
    const { folders, expenses } = get();
    
    const getAllDescendantIds = (id: string): string[] => {
      const children = folders.filter((f) => f.parentId === id);
      return [id, ...children.flatMap((c) => getAllDescendantIds(c.id))];
    };

    const allIds = getAllDescendantIds(folderId);
    return expenses
      .filter((e) => allIds.includes(e.folderId))
      .reduce((sum, e) => sum + e.value, 0);
  },

  getFolderExpenses: (folderId, recursive) => {
    const { folders, expenses } = get();
    const getPath = get().getPath;
    
    const getAllDescendantIds = (id: string): string[] => {
      const children = folders.filter((f) => f.parentId === id);
      return [id, ...children.flatMap((c) => getAllDescendantIds(c.id))];
    };

    const targetIds = recursive ? getAllDescendantIds(folderId) : [folderId];
    
    return expenses
      .filter((e) => targetIds.includes(e.folderId))
      .map((e) => {
        const path = getPath(e.folderId);
        const folder = folders.find((f) => f.id === e.folderId);
        const parent = folder?.parentId ? folders.find((f) => f.id === folder.parentId) : null;
        
        return {
          ...e,
          folderPath: path.map((p) => p.name).join(' > '),
          itemName: parent?.type === 'item' ? parent.name : folder?.type === 'item' ? folder.name : undefined,
        };
      })
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  },

  getRootFolders: () => {
    return get().folders.filter((f) => f.parentId === null);
  },
}));
